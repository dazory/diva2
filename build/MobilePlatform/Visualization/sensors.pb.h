// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensors.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sensors_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sensors_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sensors_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sensors_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sensors_2eproto;
namespace sensors {
class Cam;
struct CamDefaultTypeInternal;
extern CamDefaultTypeInternal _Cam_default_instance_;
class Can;
struct CanDefaultTypeInternal;
extern CanDefaultTypeInternal _Can_default_instance_;
class Gps;
struct GpsDefaultTypeInternal;
extern GpsDefaultTypeInternal _Gps_default_instance_;
class Imu;
struct ImuDefaultTypeInternal;
extern ImuDefaultTypeInternal _Imu_default_instance_;
class Lidar;
struct LidarDefaultTypeInternal;
extern LidarDefaultTypeInternal _Lidar_default_instance_;
class Log;
struct LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
}  // namespace sensors
PROTOBUF_NAMESPACE_OPEN
template<> ::sensors::Cam* Arena::CreateMaybeMessage<::sensors::Cam>(Arena*);
template<> ::sensors::Can* Arena::CreateMaybeMessage<::sensors::Can>(Arena*);
template<> ::sensors::Gps* Arena::CreateMaybeMessage<::sensors::Gps>(Arena*);
template<> ::sensors::Imu* Arena::CreateMaybeMessage<::sensors::Imu>(Arena*);
template<> ::sensors::Lidar* Arena::CreateMaybeMessage<::sensors::Lidar>(Arena*);
template<> ::sensors::Log* Arena::CreateMaybeMessage<::sensors::Log>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sensors {

enum ChannelOrder : int {
  GRAYSCALE = 0,
  BGR = 1,
  RGB = 2,
  BGRA = 3,
  RGBA = 4,
  OPTICAL_FLOW = 5,
  ChannelOrder_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ChannelOrder_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ChannelOrder_IsValid(int value);
constexpr ChannelOrder ChannelOrder_MIN = GRAYSCALE;
constexpr ChannelOrder ChannelOrder_MAX = OPTICAL_FLOW;
constexpr int ChannelOrder_ARRAYSIZE = ChannelOrder_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChannelOrder_descriptor();
template<typename T>
inline const std::string& ChannelOrder_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChannelOrder>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChannelOrder_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChannelOrder_descriptor(), enum_t_value);
}
inline bool ChannelOrder_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChannelOrder* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChannelOrder>(
    ChannelOrder_descriptor(), name, value);
}
// ===================================================================

class Gps PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Gps) */ {
 public:
  inline Gps() : Gps(nullptr) {}
  ~Gps() override;
  explicit constexpr Gps(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gps(const Gps& from);
  Gps(Gps&& from) noexcept
    : Gps() {
    *this = ::std::move(from);
  }

  inline Gps& operator=(const Gps& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gps& operator=(Gps&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gps& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gps* internal_default_instance() {
    return reinterpret_cast<const Gps*>(
               &_Gps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Gps& a, Gps& b) {
    a.Swap(&b);
  }
  inline void Swap(Gps* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gps* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Gps* New() const final {
    return CreateMaybeMessage<Gps>(nullptr);
  }

  Gps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Gps>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Gps& from);
  void MergeFrom(const Gps& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gps* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Gps";
  }
  protected:
  explicit Gps(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeFieldNumber = 1,
    kLongitudeFieldNumber = 2,
    kHorizontalDilutionOfPrecisionFieldNumber = 3,
  };
  // double latitude = 1;
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);
  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);
  public:

  // double longitude = 2;
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);
  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);
  public:

  // double horizontalDilutionOfPrecision = 3;
  void clear_horizontaldilutionofprecision();
  double horizontaldilutionofprecision() const;
  void set_horizontaldilutionofprecision(double value);
  private:
  double _internal_horizontaldilutionofprecision() const;
  void _internal_set_horizontaldilutionofprecision(double value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Gps)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double latitude_;
  double longitude_;
  double horizontaldilutionofprecision_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class Imu PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Imu) */ {
 public:
  inline Imu() : Imu(nullptr) {}
  ~Imu() override;
  explicit constexpr Imu(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Imu(const Imu& from);
  Imu(Imu&& from) noexcept
    : Imu() {
    *this = ::std::move(from);
  }

  inline Imu& operator=(const Imu& from) {
    CopyFrom(from);
    return *this;
  }
  inline Imu& operator=(Imu&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Imu& default_instance() {
    return *internal_default_instance();
  }
  static inline const Imu* internal_default_instance() {
    return reinterpret_cast<const Imu*>(
               &_Imu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Imu& a, Imu& b) {
    a.Swap(&b);
  }
  inline void Swap(Imu* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Imu* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Imu* New() const final {
    return CreateMaybeMessage<Imu>(nullptr);
  }

  Imu* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Imu>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Imu& from);
  void MergeFrom(const Imu& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Imu* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Imu";
  }
  protected:
  explicit Imu(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScaledAccelXFieldNumber = 1,
    kScaledAccelYFieldNumber = 2,
    kScaledAccelZFieldNumber = 3,
  };
  // float scaledAccelX = 1;
  void clear_scaledaccelx();
  float scaledaccelx() const;
  void set_scaledaccelx(float value);
  private:
  float _internal_scaledaccelx() const;
  void _internal_set_scaledaccelx(float value);
  public:

  // float scaledAccelY = 2;
  void clear_scaledaccely();
  float scaledaccely() const;
  void set_scaledaccely(float value);
  private:
  float _internal_scaledaccely() const;
  void _internal_set_scaledaccely(float value);
  public:

  // float scaledAccelZ = 3;
  void clear_scaledaccelz();
  float scaledaccelz() const;
  void set_scaledaccelz(float value);
  private:
  float _internal_scaledaccelz() const;
  void _internal_set_scaledaccelz(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Imu)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float scaledaccelx_;
  float scaledaccely_;
  float scaledaccelz_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class Cam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Cam) */ {
 public:
  inline Cam() : Cam(nullptr) {}
  ~Cam() override;
  explicit constexpr Cam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cam(const Cam& from);
  Cam(Cam&& from) noexcept
    : Cam() {
    *this = ::std::move(from);
  }

  inline Cam& operator=(const Cam& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cam& operator=(Cam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cam& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cam* internal_default_instance() {
    return reinterpret_cast<const Cam*>(
               &_Cam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Cam& a, Cam& b) {
    a.Swap(&b);
  }
  inline void Swap(Cam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Cam* New() const final {
    return CreateMaybeMessage<Cam>(nullptr);
  }

  Cam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Cam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Cam& from);
  void MergeFrom(const Cam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Cam";
  }
  protected:
  explicit Cam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageDataFieldNumber = 3,
    kColsFieldNumber = 1,
    kRowsFieldNumber = 2,
  };
  // bytes image_data = 3;
  void clear_image_data();
  const std::string& image_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_data();
  std::string* release_image_data();
  void set_allocated_image_data(std::string* image_data);
  private:
  const std::string& _internal_image_data() const;
  void _internal_set_image_data(const std::string& value);
  std::string* _internal_mutable_image_data();
  public:

  // int32 cols = 1;
  void clear_cols();
  ::PROTOBUF_NAMESPACE_ID::int32 cols() const;
  void set_cols(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cols() const;
  void _internal_set_cols(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rows = 2;
  void clear_rows();
  ::PROTOBUF_NAMESPACE_ID::int32 rows() const;
  void set_rows(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rows() const;
  void _internal_set_rows(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Cam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_data_;
  ::PROTOBUF_NAMESPACE_ID::int32 cols_;
  ::PROTOBUF_NAMESPACE_ID::int32 rows_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class Lidar PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Lidar) */ {
 public:
  inline Lidar() : Lidar(nullptr) {}
  ~Lidar() override;
  explicit constexpr Lidar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lidar(const Lidar& from);
  Lidar(Lidar&& from) noexcept
    : Lidar() {
    *this = ::std::move(from);
  }

  inline Lidar& operator=(const Lidar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lidar& operator=(Lidar&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Lidar& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lidar* internal_default_instance() {
    return reinterpret_cast<const Lidar*>(
               &_Lidar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Lidar& a, Lidar& b) {
    a.Swap(&b);
  }
  inline void Swap(Lidar* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lidar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Lidar* New() const final {
    return CreateMaybeMessage<Lidar>(nullptr);
  }

  Lidar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Lidar>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Lidar& from);
  void MergeFrom(const Lidar& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lidar* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Lidar";
  }
  protected:
  explicit Lidar(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:sensors.Lidar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class Can PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Can) */ {
 public:
  inline Can() : Can(nullptr) {}
  ~Can() override;
  explicit constexpr Can(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Can(const Can& from);
  Can(Can&& from) noexcept
    : Can() {
    *this = ::std::move(from);
  }

  inline Can& operator=(const Can& from) {
    CopyFrom(from);
    return *this;
  }
  inline Can& operator=(Can&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Can& default_instance() {
    return *internal_default_instance();
  }
  static inline const Can* internal_default_instance() {
    return reinterpret_cast<const Can*>(
               &_Can_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Can& a, Can& b) {
    a.Swap(&b);
  }
  inline void Swap(Can* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Can* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Can* New() const final {
    return CreateMaybeMessage<Can>(nullptr);
  }

  Can* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Can>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Can& from);
  void MergeFrom(const Can& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Can* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Can";
  }
  protected:
  explicit Can(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // float type = 1;
  void clear_type();
  float type() const;
  void set_type(float value);
  private:
  float _internal_type() const;
  void _internal_set_type(float value);
  public:

  // float data = 2;
  void clear_data();
  float data() const;
  void set_data(float value);
  private:
  float _internal_data() const;
  void _internal_set_data(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Can)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float type_;
  float data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class Log PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Log) */ {
 public:
  inline Log() : Log(nullptr) {}
  ~Log() override;
  explicit constexpr Log(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Log(const Log& from);
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Log& default_instance() {
    return *internal_default_instance();
  }
  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }
  inline void Swap(Log* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Log* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Log* New() const final {
    return CreateMaybeMessage<Log>(nullptr);
  }

  Log* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Log& from);
  void MergeFrom(const Log& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Log";
  }
  protected:
  explicit Log(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPadFieldNumber = 4,
    kRes0FieldNumber = 5,
    kRes1FieldNumber = 6,
    kDataFieldNumber = 7,
    kCanIdFieldNumber = 2,
    kCanDlcFieldNumber = 3,
  };
  // bytes __pad = 4;
  void clear___pad();
  const std::string& __pad() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set___pad(ArgT0&& arg0, ArgT... args);
  std::string* mutable___pad();
  std::string* release___pad();
  void set_allocated___pad(std::string* __pad);
  private:
  const std::string& _internal___pad() const;
  void _internal_set___pad(const std::string& value);
  std::string* _internal_mutable___pad();
  public:

  // bytes __res0 = 5;
  void clear___res0();
  const std::string& __res0() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set___res0(ArgT0&& arg0, ArgT... args);
  std::string* mutable___res0();
  std::string* release___res0();
  void set_allocated___res0(std::string* __res0);
  private:
  const std::string& _internal___res0() const;
  void _internal_set___res0(const std::string& value);
  std::string* _internal_mutable___res0();
  public:

  // bytes __res1 = 6;
  void clear___res1();
  const std::string& __res1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set___res1(ArgT0&& arg0, ArgT... args);
  std::string* mutable___res1();
  std::string* release___res1();
  void set_allocated___res1(std::string* __res1);
  private:
  const std::string& _internal___res1() const;
  void _internal_set___res1(const std::string& value);
  std::string* _internal_mutable___res1();
  public:

  // bytes data = 7;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint32 can_id = 2;
  void clear_can_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 can_id() const;
  void set_can_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_can_id() const;
  void _internal_set_can_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 can_dlc = 3;
  void clear_can_dlc();
  ::PROTOBUF_NAMESPACE_ID::uint32 can_dlc() const;
  void set_can_dlc(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_can_dlc() const;
  void _internal_set_can_dlc(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Log)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr __pad_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr __res0_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr __res1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 can_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 can_dlc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Gps

// double latitude = 1;
inline void Gps::clear_latitude() {
  latitude_ = 0;
}
inline double Gps::_internal_latitude() const {
  return latitude_;
}
inline double Gps::latitude() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.latitude)
  return _internal_latitude();
}
inline void Gps::_internal_set_latitude(double value) {
  
  latitude_ = value;
}
inline void Gps::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.latitude)
}

// double longitude = 2;
inline void Gps::clear_longitude() {
  longitude_ = 0;
}
inline double Gps::_internal_longitude() const {
  return longitude_;
}
inline double Gps::longitude() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.longitude)
  return _internal_longitude();
}
inline void Gps::_internal_set_longitude(double value) {
  
  longitude_ = value;
}
inline void Gps::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.longitude)
}

// double horizontalDilutionOfPrecision = 3;
inline void Gps::clear_horizontaldilutionofprecision() {
  horizontaldilutionofprecision_ = 0;
}
inline double Gps::_internal_horizontaldilutionofprecision() const {
  return horizontaldilutionofprecision_;
}
inline double Gps::horizontaldilutionofprecision() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.horizontalDilutionOfPrecision)
  return _internal_horizontaldilutionofprecision();
}
inline void Gps::_internal_set_horizontaldilutionofprecision(double value) {
  
  horizontaldilutionofprecision_ = value;
}
inline void Gps::set_horizontaldilutionofprecision(double value) {
  _internal_set_horizontaldilutionofprecision(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.horizontalDilutionOfPrecision)
}

// -------------------------------------------------------------------

// Imu

// float scaledAccelX = 1;
inline void Imu::clear_scaledaccelx() {
  scaledaccelx_ = 0;
}
inline float Imu::_internal_scaledaccelx() const {
  return scaledaccelx_;
}
inline float Imu::scaledaccelx() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.scaledAccelX)
  return _internal_scaledaccelx();
}
inline void Imu::_internal_set_scaledaccelx(float value) {
  
  scaledaccelx_ = value;
}
inline void Imu::set_scaledaccelx(float value) {
  _internal_set_scaledaccelx(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.scaledAccelX)
}

// float scaledAccelY = 2;
inline void Imu::clear_scaledaccely() {
  scaledaccely_ = 0;
}
inline float Imu::_internal_scaledaccely() const {
  return scaledaccely_;
}
inline float Imu::scaledaccely() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.scaledAccelY)
  return _internal_scaledaccely();
}
inline void Imu::_internal_set_scaledaccely(float value) {
  
  scaledaccely_ = value;
}
inline void Imu::set_scaledaccely(float value) {
  _internal_set_scaledaccely(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.scaledAccelY)
}

// float scaledAccelZ = 3;
inline void Imu::clear_scaledaccelz() {
  scaledaccelz_ = 0;
}
inline float Imu::_internal_scaledaccelz() const {
  return scaledaccelz_;
}
inline float Imu::scaledaccelz() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.scaledAccelZ)
  return _internal_scaledaccelz();
}
inline void Imu::_internal_set_scaledaccelz(float value) {
  
  scaledaccelz_ = value;
}
inline void Imu::set_scaledaccelz(float value) {
  _internal_set_scaledaccelz(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.scaledAccelZ)
}

// -------------------------------------------------------------------

// Cam

// int32 cols = 1;
inline void Cam::clear_cols() {
  cols_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cam::_internal_cols() const {
  return cols_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cam::cols() const {
  // @@protoc_insertion_point(field_get:sensors.Cam.cols)
  return _internal_cols();
}
inline void Cam::_internal_set_cols(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cols_ = value;
}
inline void Cam::set_cols(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cols(value);
  // @@protoc_insertion_point(field_set:sensors.Cam.cols)
}

// int32 rows = 2;
inline void Cam::clear_rows() {
  rows_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cam::_internal_rows() const {
  return rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cam::rows() const {
  // @@protoc_insertion_point(field_get:sensors.Cam.rows)
  return _internal_rows();
}
inline void Cam::_internal_set_rows(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rows_ = value;
}
inline void Cam::set_rows(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:sensors.Cam.rows)
}

// bytes image_data = 3;
inline void Cam::clear_image_data() {
  image_data_.ClearToEmpty();
}
inline const std::string& Cam::image_data() const {
  // @@protoc_insertion_point(field_get:sensors.Cam.image_data)
  return _internal_image_data();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Cam::set_image_data(ArgT0&& arg0, ArgT... args) {
 
 image_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:sensors.Cam.image_data)
}
inline std::string* Cam::mutable_image_data() {
  // @@protoc_insertion_point(field_mutable:sensors.Cam.image_data)
  return _internal_mutable_image_data();
}
inline const std::string& Cam::_internal_image_data() const {
  return image_data_.Get();
}
inline void Cam::_internal_set_image_data(const std::string& value) {
  
  image_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Cam::_internal_mutable_image_data() {
  
  return image_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Cam::release_image_data() {
  // @@protoc_insertion_point(field_release:sensors.Cam.image_data)
  return image_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Cam::set_allocated_image_data(std::string* image_data) {
  if (image_data != nullptr) {
    
  } else {
    
  }
  image_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:sensors.Cam.image_data)
}

// -------------------------------------------------------------------

// Lidar

// .google.protobuf.Timestamp timestamp = 1;
inline bool Lidar::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool Lidar::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Lidar::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Lidar::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.Lidar.timestamp)
  return _internal_timestamp();
}
inline void Lidar::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.Lidar.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Lidar::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Lidar::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.Lidar.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Lidar::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Lidar::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:sensors.Lidar.timestamp)
  return _internal_mutable_timestamp();
}
inline void Lidar::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.Lidar.timestamp)
}

// -------------------------------------------------------------------

// Can

// float type = 1;
inline void Can::clear_type() {
  type_ = 0;
}
inline float Can::_internal_type() const {
  return type_;
}
inline float Can::type() const {
  // @@protoc_insertion_point(field_get:sensors.Can.type)
  return _internal_type();
}
inline void Can::_internal_set_type(float value) {
  
  type_ = value;
}
inline void Can::set_type(float value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensors.Can.type)
}

// float data = 2;
inline void Can::clear_data() {
  data_ = 0;
}
inline float Can::_internal_data() const {
  return data_;
}
inline float Can::data() const {
  // @@protoc_insertion_point(field_get:sensors.Can.data)
  return _internal_data();
}
inline void Can::_internal_set_data(float value) {
  
  data_ = value;
}
inline void Can::set_data(float value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:sensors.Can.data)
}

// -------------------------------------------------------------------

// Log

// uint32 can_id = 2;
inline void Log::clear_can_id() {
  can_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Log::_internal_can_id() const {
  return can_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Log::can_id() const {
  // @@protoc_insertion_point(field_get:sensors.Log.can_id)
  return _internal_can_id();
}
inline void Log::_internal_set_can_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  can_id_ = value;
}
inline void Log::set_can_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_can_id(value);
  // @@protoc_insertion_point(field_set:sensors.Log.can_id)
}

// uint32 can_dlc = 3;
inline void Log::clear_can_dlc() {
  can_dlc_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Log::_internal_can_dlc() const {
  return can_dlc_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Log::can_dlc() const {
  // @@protoc_insertion_point(field_get:sensors.Log.can_dlc)
  return _internal_can_dlc();
}
inline void Log::_internal_set_can_dlc(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  can_dlc_ = value;
}
inline void Log::set_can_dlc(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_can_dlc(value);
  // @@protoc_insertion_point(field_set:sensors.Log.can_dlc)
}

// bytes __pad = 4;
inline void Log::clear___pad() {
  __pad_.ClearToEmpty();
}
inline const std::string& Log::__pad() const {
  // @@protoc_insertion_point(field_get:sensors.Log.__pad)
  return _internal___pad();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Log::set___pad(ArgT0&& arg0, ArgT... args) {
 
 __pad_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:sensors.Log.__pad)
}
inline std::string* Log::mutable___pad() {
  // @@protoc_insertion_point(field_mutable:sensors.Log.__pad)
  return _internal_mutable___pad();
}
inline const std::string& Log::_internal___pad() const {
  return __pad_.Get();
}
inline void Log::_internal_set___pad(const std::string& value) {
  
  __pad_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Log::_internal_mutable___pad() {
  
  return __pad_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Log::release___pad() {
  // @@protoc_insertion_point(field_release:sensors.Log.__pad)
  return __pad_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Log::set_allocated___pad(std::string* __pad) {
  if (__pad != nullptr) {
    
  } else {
    
  }
  __pad_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), __pad,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:sensors.Log.__pad)
}

// bytes __res0 = 5;
inline void Log::clear___res0() {
  __res0_.ClearToEmpty();
}
inline const std::string& Log::__res0() const {
  // @@protoc_insertion_point(field_get:sensors.Log.__res0)
  return _internal___res0();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Log::set___res0(ArgT0&& arg0, ArgT... args) {
 
 __res0_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:sensors.Log.__res0)
}
inline std::string* Log::mutable___res0() {
  // @@protoc_insertion_point(field_mutable:sensors.Log.__res0)
  return _internal_mutable___res0();
}
inline const std::string& Log::_internal___res0() const {
  return __res0_.Get();
}
inline void Log::_internal_set___res0(const std::string& value) {
  
  __res0_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Log::_internal_mutable___res0() {
  
  return __res0_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Log::release___res0() {
  // @@protoc_insertion_point(field_release:sensors.Log.__res0)
  return __res0_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Log::set_allocated___res0(std::string* __res0) {
  if (__res0 != nullptr) {
    
  } else {
    
  }
  __res0_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), __res0,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:sensors.Log.__res0)
}

// bytes __res1 = 6;
inline void Log::clear___res1() {
  __res1_.ClearToEmpty();
}
inline const std::string& Log::__res1() const {
  // @@protoc_insertion_point(field_get:sensors.Log.__res1)
  return _internal___res1();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Log::set___res1(ArgT0&& arg0, ArgT... args) {
 
 __res1_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:sensors.Log.__res1)
}
inline std::string* Log::mutable___res1() {
  // @@protoc_insertion_point(field_mutable:sensors.Log.__res1)
  return _internal_mutable___res1();
}
inline const std::string& Log::_internal___res1() const {
  return __res1_.Get();
}
inline void Log::_internal_set___res1(const std::string& value) {
  
  __res1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Log::_internal_mutable___res1() {
  
  return __res1_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Log::release___res1() {
  // @@protoc_insertion_point(field_release:sensors.Log.__res1)
  return __res1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Log::set_allocated___res1(std::string* __res1) {
  if (__res1 != nullptr) {
    
  } else {
    
  }
  __res1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), __res1,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:sensors.Log.__res1)
}

// bytes data = 7;
inline void Log::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& Log::data() const {
  // @@protoc_insertion_point(field_get:sensors.Log.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Log::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:sensors.Log.data)
}
inline std::string* Log::mutable_data() {
  // @@protoc_insertion_point(field_mutable:sensors.Log.data)
  return _internal_mutable_data();
}
inline const std::string& Log::_internal_data() const {
  return data_.Get();
}
inline void Log::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Log::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Log::release_data() {
  // @@protoc_insertion_point(field_release:sensors.Log.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Log::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:sensors.Log.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sensors

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sensors::ChannelOrder> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::ChannelOrder>() {
  return ::sensors::ChannelOrder_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sensors_2eproto
